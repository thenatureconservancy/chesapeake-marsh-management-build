import{bK as K,r0 as R,b as ft,bl as Q,r1 as J,eG as tt,g as I,n as et,r as u,o as c,p as nt,am as x,r2 as D,r3 as mt,r4 as vt,au as y,bd as N,dN as A,dq as gt,aZ as yt,dt as _t,b2 as St,a$ as Et,kf as V,P as at,ok as Z,fq as M,al as j,jK as xt,c1 as bt,d_ as wt,r5 as _,c0 as Pt,mS as Rt,a as Mt,jE as Tt}from"./index-v3vBpdnQ.js";import{R as $t,L as Ct}from"./quat-CzjAuFtU.js";import{x as it,k as Ft}from"./hydratedFeatures-Cq6vhkEz.js";import{c as zt}from"./meshVertexSpaceUtils-CBUTOjIq.js";import{E as q,e as At}from"./SnappingContext-mEkajMTm.js";function Wt(n,t){return n===t||n!=null&&t!=null&&K(n.spatialReference,t.spatialReference)&&n.x===t.x&&n.y===t.y&&n.z===t.z&&n.m===t.m}function Jt(n,t,e){return n===t||n!=null&&t!=null&&K(n.spatialReference,t.spatialReference)&&R(n.x,t.x,e)&&R(n.y,t.y,e)&&R(n.z??0,t.z??0,e)&&R(n.m??0,t.m??0,e)}let E=class extends ft{constructor(t){super(t),this.constrainResult=e=>e,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=Q(async(e,a,i,s)=>{const r=this._frameTask;if(r==null)return;const o=await r.schedule(()=>a.snap({...e,context:i,signal:s}),s);o.valid&&await r.schedule(()=>{this.stagedPoint=o.apply(),e!==this._snapPoints&&this._snapPoints!=null&&(this.stagedPoint=a.update({...this._snapPoints,context:i}))},s)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(t){this._stagedPoint=this.constrainResult(t)}initialize(){const t=this.view.type==="3d"?this.view?.resourceController?.scheduler:null;this._frameTask=t!=null?t.registerTask(tt.SNAPPING):J}destroy(){this._abortController=I(this._abortController),this._frameTask=et(this._frameTask)}update(t,e,a){this._snapPoints=t;const{point:i,scenePoint:s}=t,r=e.update({point:i,scenePoint:s,context:a});return this.stagedPoint=r,r}async snap(t,e,a){const{point:i,scenePoint:s}=t;return this.stagedPoint=e.update({point:i,scenePoint:s,context:a}),this._snapPoints=t,this._abortController==null&&(this._abortController=new AbortController),this._snap(t,e,a,this._abortController.signal)}async snapAgainNearPreviousMapPoint(t,e){this._snapPoints!=null&&await this.snap(this._snapPoints,t,e)}abort(){this._abortController=I(this._abortController),this._snapPoints=null}};u([c({constructOnly:!0})],E.prototype,"view",void 0),u([c()],E.prototype,"stagedPoint",null),u([c()],E.prototype,"constrainResult",void 0),u([c()],E.prototype,"_stagedPoint",void 0),E=u([nt("esri.views.interactive.snapping.SnappingOperation")],E);const ee=["freehand","hybrid","click"],ne="click";function T(n,t,e=null){return e!=null?[n,t,e]:[n,t]}function st(n,t,e=null){return e!=null?{x:n,y:t,z:e}:{x:n,y:t}}let rt=class{constructor(t){this.spatialReference=t}mapToLocalMultiple(t){return t.map(e=>this.mapToLocal(e)).filter(at)}get doUnnormalization(){return!1}},It=class extends rt{constructor(t,e,a=null){super(e),this._defaultZ=a,this.transform=D(),this.transformInv=D(),this.transform=mt(t),vt(this.transformInv,this.transform)}makeMapPoint(t,e){return T(t,e,this._defaultZ)}mapToLocal(t){return st(this.transform[0]*t[0]+this.transform[2]*t[1]+this.transform[4],this.transform[1]*t[0]+this.transform[3]*t[1]+this.transform[5])}localToMap(t){return T(this.transformInv[0]*t.x+this.transformInv[2]*t.y+this.transformInv[4],this.transformInv[1]*t.x+this.transformInv[3]*t.y+this.transformInv[5],this._defaultZ)}};class Zt extends rt{constructor(t,e){super(t.spatialReference),this.view=t,this.defaultZ=null,this.pWS=y(),this.tangentFrameUpWS=y(),this.tangentFrameRightWS=y(),this.tangentFrameForwardWS=y(),this.localFrameRightWS=y(),this.localFrameUpWS=y(),this.worldToLocalTransform=N(),this.localToWorldTransform=N(),this.scale=1,this.scale=t.resolution,this.referenceMapPoint=e,this.defaultZ=e.hasZ?e.z:null;const a=t.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,A.X,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,A.Y,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,A.Z,this.tangentFrameForwardWS);const i=y();gt(i,this.tangentFrameForwardWS,yt(a,this.tangentFrameForwardWS)),_t(this.localFrameRightWS,a,i),St(this.localFrameRightWS,this.localFrameRightWS),Et(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),$t(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),Ct(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(t,e){return T(t,e,this.defaultZ)}mapToLocal(t){const e=y();this.view.renderCoordsHelper.toRenderCoords(new x({x:t[0],y:t[1],spatialReference:this.spatialReference}),e),V(e,e,this.worldToLocalTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(e,new x({spatialReference:this.view.spatialReference}));return a!=null?st(a.x/this.scale,a.y/this.scale):null}localToMap(t){const e=y();this.view.renderCoordsHelper.toRenderCoords(new x({x:t.x*this.scale,y:t.y*this.scale,spatialReference:this.spatialReference}),e),V(e,e,this.localToWorldTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(e,new x({spatialReference:this.view.spatialReference}));return a!=null?T(a.x,a.y,this.defaultZ):null}}function se(n,t){if(n.type==="2d")return new It(n.state.transform,n.spatialReference,t.length>2?t[2]:null);if(n.type==="3d"){const e=t.length>2?new x({x:t[0],y:t[1],z:t[2],spatialReference:n.spatialReference}):new x({x:t[0],y:t[1],spatialReference:n.spatialReference});return new Zt(n,e)}return null}function kt(n,t){let e=null,a=null;return i=>{if(i.action==="cancel")return void(a!=null&&(a.execute({action:"cancel"}),e=null,a=null));const s={action:i.action,screenStart:i.start,screenEnd:i.screenPoint};i.action==="start"&&e==null&&(e=new w,a=new w,t(n,e,a,i.pointerType,s)),e?.execute(s),i.action==="end"&&e!=null&&(e=null,a=null)}}function re(n,t){return n.events.on("drag",kt(n,t))}function oe(n,t){const e=[n.x,n.y,n.z??0],a=t,i=[Math.cos(a),Math.sin(a)],s=Math.sqrt(i[0]*i[0]+i[1]*i[1]);if(s===0)return null;i[0]/=s,i[1]/=s;const r=o=>{const l=(o.x-e[0])*i[0]+(o.y-e[1])*i[1];o.x=e[0]+l*i[0],o.y=e[1]+l*i[1]};return o=>(r(o.mapStart),r(o.mapEnd),{...o,axis:i})}function Ht(n){let t=null;return e=>{if(e.action==="start"&&(t=Ut(n,e.mapStart.spatialReference)),t==null)return null;const a=e.mapEnd.x-e.mapStart.x,i=e.mapEnd.y-e.mapStart.y,s=(e.mapEnd.z??0)-(e.mapStart.z??0);return t.move(a,i,s,e.action),{...e,translationX:a,translationY:i,translationZ:s}}}function X(n,t){return n==null?null:n.spatialReference.equals(t)?n.clone():M(n,t)}function Ut(n,t){const e=n.operations;if(!e)return null;const a=e.data.geometry,i=Ft(t);if(a.spatialReference.equals(i))return W(n,e,()=>{});if(a.type!=="mesh"){const s=X(a,i);if(s==null)return null;const r=a.spatialReference;return W(n,q.fromGeometry(s,e.viewingMode),()=>{const o=M(a,r);e.trySetGeometry(o)})}if(zt(a)){const s=X(a.origin,i);if(!s)return null;const r=a.spatialReference,o=q.fromGeometry(s,e.viewingMode);return W(n,e,()=>{const l=M(o.data.geometry,r),p=l.x-a.origin.x,d=l.y-a.origin.y,m=(l.z??0)-(a.origin.z??0);e.move(p,d,m)})}return null}function W(n,t,e){let a=0,i=0,s=0;return{move:(r,o,l,p)=>{p==="start"&&(a=0,i=0,s=0);const d=r-a,m=o-i,v=l-s;t.move(d,m,v),a+=d,i+=m,s+=v,e(),p==="end"&&n.endInteraction?.()}}}function le(n,t=null,e){let a=null;const i=t==null||n.spatialReference?.equals(t)?r=>r:r=>r!=null?M(r,t):r,s={exclude:[],...e};return r=>{if(r.action==="start"&&(a=i(n.toMap(r.screenStart,s))),a==null)return null;const o=i(n.toMap(r.screenEnd,s));return o!=null?{...r,mapStart:a,mapEnd:o}:null}}function ue(n){const t=n.map(e=>Ht(e)).filter(at);return e=>{const a=e.mapEnd.x-e.mapStart.x,i=e.mapEnd.y-e.mapStart.y,s=e.mapEnd.z-e.mapStart.z;return t.forEach(r=>r(e)),{...e,translationX:a,translationY:i,translationZ:s}}}function Gt(n){const t=n.operations?.createResetState();return e=>(t?.remove(),e)}function ce(n){const t=n.map(e=>Gt(e)).filter(e=>e!=null);return e=>(t.forEach(a=>a(e)),e)}function he(){let n=0,t=0,e=0;return a=>{a.action==="start"&&(n=a.mapStart.x,t=a.mapStart.y,e=a.mapStart.z);const i=a.mapEnd.x-n,s=a.mapEnd.y-t,r=a.mapEnd.z-e;return n=a.mapEnd.x,t=a.mapEnd.y,e=a.mapEnd.z,{...a,mapDeltaX:i,mapDeltaY:s,mapDeltaZ:r,mapDeltaSpatialReference:a.mapStart.spatialReference}}}function pe(){let n=0,t=0;return e=>{e.action==="start"&&(n=e.screenStart.x,t=e.screenStart.y);const a=e.screenEnd.x-n,i=e.screenEnd.y-t;return n=e.screenEnd.x,t=e.screenEnd.y,{...e,screenDeltaX:a,screenDeltaY:i}}}function de(n,t){let e=null,a=0,i=0;return s=>{if(s.action==="start"&&(e=n.toScreen?.(t),e!=null&&(e.x<0||e.x>n.width||e.y<0||e.y>n.height?e=null:(a=s.screenStart.x-e.x,i=s.screenStart.y-e.y))),e==null)return null;const r=j(s.screenEnd.x-a,0,n.width),o=j(s.screenEnd.y-i,0,n.height),l=xt(r,o);return s.screenStart=e,s.screenEnd=l,s}}const Ot=()=>{};class w{constructor(){this.execute=Ot}next(t,e=new w){return t!=null&&(this.execute=a=>{const i=t(a);i!=null&&e.execute(i)}),e}}function fe(n,t,e=[]){if(n.type==="2d")return i=>i;let a=null;return i=>{i.action==="start"&&(a=n.toMap(i.screenStart,{exclude:e}),a!=null&&(a.z=Z(a,n,t)));const s=n.toMap(i.screenEnd,{exclude:e});s!=null&&(s.z=Z(s,n,t));const r=a!=null&&s!=null?{sceneStart:a,sceneEnd:s}:null;return{...i,scenePoints:r}}}function Y(n,t,e){const a=t.elevationProvider.getElevation(n.x,n.y,n.z??0,n.spatialReference,"scene")??0,i=it(n);return i.z=a,i.hasZ=!0,i.z=Z(i,t,e),i}function me(n,t){if(n.type==="2d")return a=>a;let e=null;return a=>{a.action==="start"&&(e=Y(a.mapStart,n,t));const i=Y(a.mapEnd,n,t),s=e!=null&&i!=null?{sceneStart:e,sceneEnd:i}:null;return{...a,scenePoints:s}}}var S;(function(n){n[n.WhenToolEditable=0]="WhenToolEditable",n[n.WhenToolNotEditable=1]="WhenToolNotEditable",n[n.Always=2]="Always"})(S||(S={}));class Lt{constructor(){this._isToolEditable=!0,this._manipulators=new bt,this._resourceContexts={manipulator3D:{}},this._attached=!1}set isToolEditable(t){this._isToolEditable=t}get length(){return this._manipulators.length}add(t,e=S.WhenToolEditable){this.addMany([t],e)}addMany(t,e=S.WhenToolEditable){for(const a of t){const i={manipulator:a,visibilityPredicate:e,attached:!1};this._manipulators.add(i),this._attached&&this._updateManipulatorAttachment(i)}}remove(t){for(let e=0;e<this._manipulators.length;e++)if(this._manipulators.at(e).manipulator===t){const a=this._manipulators.splice(e,1)[0];this._detachManipulator(a);break}}removeAll(){this._manipulators.forEach(t=>{this._detachManipulator(t)}),this._manipulators.removeAll()}attach(){this._manipulators.forEach(t=>{this._updateManipulatorAttachment(t)}),this._attached=!0}detach(){this._manipulators.forEach(t=>{this._detachManipulator(t)}),this._attached=!1}destroy(){this.detach(),this._manipulators.forEach(({manipulator:t})=>t.destroy()),this._manipulators.destroy(),this._resourceContexts=null}on(t,e){return this._manipulators.on(t,a=>{e(a)})}forEach(t){for(const e of this._manipulators.items)t(e)}some(t){return this._manipulators.items.some(t)}toArray(){const t=[];return this.forEach(e=>t.push(e.manipulator)),t}intersect(t,e){let a=null,i=Number.MAX_VALUE;return this._manipulators.forEach(({manipulator:s,attached:r})=>{if(!r||!s.interactive)return;const o=s.intersectionDistance(t,e);o!=null&&o<i&&(i=o,a=s)}),a}_updateManipulatorAttachment(t){this._isManipulatorItemVisible(t)?this._attachManipulator(t):this._detachManipulator(t)}_attachManipulator(t){t.attached||(t.manipulator.attach&&t.manipulator.attach(this._resourceContexts),t.attached=!0)}_detachManipulator(t){if(!t.attached)return;const e=t.manipulator;e.grabbing=!1,e.dragging=!1,e.hovering=!1,e.selected=!1,e.detach&&e.detach(this._resourceContexts),t.attached=!1}_isManipulatorItemVisible(t){return t.visibilityPredicate===S.Always||(this._isToolEditable?t.visibilityPredicate===S.WhenToolEditable:t.visibilityPredicate===S.WhenToolNotEditable)}}let h=class extends wt.EventedAccessor{constructor(n){super(n),this.manipulators=new Lt,this.automaticManipulatorSelection=!0,this.hasGrabbedManipulators=!1,this.hasHoveredManipulators=!1,this.firstGrabbedManipulator=null,this.created=!1,this.removeIncompleteOnCancel=!0,this._editableFlags=new Map([[_.MANAGER,!0],[_.USER,!0]]),this._creationFinishedResolver=Pt()}get active(){return this.view!=null&&this.view.activeTool===this}set visible(n){this._get("visible")!==n&&(this._set("visible",n),this._syncVisible())}get editable(){return this.getEditableFlag(_.USER)}set editable(n){this.setEditableFlag(_.USER,n)}get updating(){return!1}get cursor(){return null}get hasFocusedManipulators(){return this.hasGrabbedManipulators||this.hasHoveredManipulators}destroy(){this.manipulators.destroy(),this._set("view",null)}onAdd(){this._syncVisible()}activate(){this.view!=null&&(this.view.focus(),this.onActivate())}deactivate(){this.onDeactivate()}cancel(){this.emit("cancel")}handleInputEvent(n){this.onInputEvent(n)}handleInputEventAfter(n){this.onInputEventAfter(n)}setEditableFlag(n,t){this._editableFlags.set(n,t),this.manipulators.isToolEditable=this.internallyEditable,this._updateManipulatorAttachment(),n===_.USER&&this.notifyChange("editable"),this.onEditableChange(),this.onManipulatorSelectionChanged()}getEditableFlag(n){return this._editableFlags.get(n)??!1}endDrag(){const n=this.view.inputManager.latestPointerLocation;if(!n)return;let t=!1;this.manipulators.forEach(({manipulator:e})=>{e.dragging&&(t=!0,e.events.emit("drag",{action:"end",start:n,screenPoint:n}))}),t&&(this.view.toolViewManager.activeTool=null)}whenCreated(){return this._creationFinishedResolver.promise}onManipulatorSelectionChanged(){}onActivate(){}onDeactivate(){}onShow(){}onHide(){}onEditableChange(){}onInputEvent(n){}onInputEventAfter(n){}get internallyEditable(){return this.getEditableFlag(_.USER)&&this.getEditableFlag(_.MANAGER)}finishToolCreation(){this.created||this._creationFinishedResolver.resolve(this),this._set("created",!0)}_syncVisible(){if(this.initialized){if(this.visible)this._show();else if(this._hide(),this.active)return void(this.view.activeTool=null)}}_show(){this._updateManipulatorAttachment(),this.onShow()}_hide(){this._updateManipulatorAttachment(),this.onHide()}_updateManipulatorAttachment(){this.visible?this.manipulators.attach():this.manipulators.detach()}};u([c({constructOnly:!0})],h.prototype,"view",void 0),u([c({readOnly:!0})],h.prototype,"active",null),u([c({value:!0})],h.prototype,"visible",null),u([c({value:!0})],h.prototype,"editable",null),u([c({readOnly:!0})],h.prototype,"manipulators",void 0),u([c({readOnly:!0})],h.prototype,"updating",null),u([c()],h.prototype,"cursor",null),u([c({readOnly:!0})],h.prototype,"automaticManipulatorSelection",void 0),u([c()],h.prototype,"hasFocusedManipulators",null),u([c()],h.prototype,"hasGrabbedManipulators",void 0),u([c()],h.prototype,"hasHoveredManipulators",void 0),u([c()],h.prototype,"firstGrabbedManipulator",void 0),u([c({readOnly:!0})],h.prototype,"created",void 0),u([c({readOnly:!0})],h.prototype,"removeIncompleteOnCancel",void 0),h=u([nt("esri.views.interactive.InteractiveToolBase")],h);function ve({predicate:n=()=>!0,snappingManager:t,snappingContext:e,updatingHandles:a,useZ:i=!0}){const s=new w;if(t==null)return{snappingStep:[B,s],cancelSnapping:B};let r,o=null,l=null,p=null;const d=()=>{o=I(o),t.doneSnapping(),l?.frameTask.remove(),l=null,r=et(r),p=null},m=Dt(t,i,s);let v=null,g=null,H=null;return{snappingStep:[f=>{if(!n(f))return f;const{action:$}=f;if($==="start"){const{info:P}=f,C=Nt(t.view);if(l=Vt(e,f,C),l.context.selfSnappingZ=null,!i&&P!=null){const b=qt(e.coordinateHelper,P.handle.component);b!=null&&(l.context.selfSnappingZ={value:b,elevationInfo:e.elevationInfo??Rt})}}if(l!=null){const{context:P,originalScenePos:C,originalPos:b}=l,{mapEnd:U,mapStart:G,scenePoints:ut}=f,F=ot(b,k(U,G)),O=k(G,b),ct={...f,action:"update"},ht=l.context,z=jt(C,ut),L=t.update({point:F,scenePoint:z,context:P});if(H=L,lt(U,L,O,i),v=F,g=z,$!=="end"){const{frameTask:pt}=l;o==null&&(o=new AbortController),p=dt=>{a.addPromise(Tt(m({frameTask:pt,event:ct,context:ht,point:F,scenePoint:z,delta:O,getLastState:()=>({point:v,scenePoint:g,updatePoint:dt.forceUpdate?null:H})},o.signal)))},p({forceUpdate:!1}),r==null&&(r=Mt(()=>t.options.effectiveEnabled,()=>p?.({forceUpdate:!0})))}}return $==="end"&&d(),f},s],cancelSnapping:f=>(d(),f)}}function Dt(n,t,e){return Q(async({frameTask:a,point:i,scenePoint:s,context:r,event:o,delta:l,getLastState:p},d)=>{const m=await a.schedule(()=>n.snap({point:i,scenePoint:s,context:r,signal:d}),d);if(m.valid){let v=await a.schedule(()=>m.apply(),d);const g=p();g.point!=null&&i!==g.point&&(v=n.update({point:g.point,scenePoint:g.scenePoint,context:r})),g.updatePoint!=null&&Wt(v,g.updatePoint)||(lt(o.mapEnd,v,l,t),e.execute(o))}})}function Nt(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(tt.SNAPPING):J}function Vt(n,t,e){return{context:new At({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:t.info!=null?t.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:t.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,originalScenePos:t.scenePoints!=null?t.scenePoints.sceneStart:null,frameTask:e}}function ot(n,[t,e,a]){const i=it(n);return i.x+=t,i.y+=e,i.hasZ&&(i.z+=a),i}function jt(n,t){return n==null||t==null?null:ot(n,k(t.sceneEnd,t.sceneStart))}function k(n,t){const e=n.hasZ&&t.hasZ?n.z-t.z:0;return[n.x-t.x,n.y-t.y,e]}function lt(n,t,[e,a,i],s){n.x=t.x+e,n.y=t.y+a,s&&n.hasZ&&t.hasZ&&(n.z=t.z+i)}function qt(n,t){if(!n.hasZ())return null;const e=t.vertices;let a=null;for(const i of e){const s=n.getZ(i.pos);if(a!=null&&s!=null&&Math.abs(s-a)>1e-6)return null;a==null&&(a=s)}return a}function B(n){return n}export{fe as D,le as E,se as F,me as G,de as M,ue as S,Ht as a,E as b,Wt as c,ee as d,ne as e,ve as f,w as g,Gt as h,Jt as i,pe as j,he as k,oe as m,h as n,re as p,It as v,st as w,ce as z};
