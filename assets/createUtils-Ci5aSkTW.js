import{aE as k,ae as H,jf as N,iH as Q,fE as A,i8 as B,iF as D,jg as J,jh as K,ji as V,ap as X,r as w,o as P,am as Z,p as Y,jj as ee,eQ as te,gE as _,P as C,aR as ae,T as se,jk as ne,jl as G,an as re,aF as ie,au as q,jm as oe}from"./index-v3vBpdnQ.js";import{c as le}from"./distanceOperator-xsfQRCMv.js";import{c as ce,u as ue}from"./simplifyOperator-DXPhKWio.js";import{w as o}from"./SnappingDragPipelineStep-cw-qmV7t.js";var I;let m=I=class extends k{constructor(n){super(n),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const n=this.center,t=this.numberOfPoints;if(this.hasZ=n?.hasZ??!1,this.rings.length!==0||!n)return;const i=H(this.radius,this.radiusUnit,"meters"),s=n.spatialReference;let r,e="geographic";if(s.isWebMercator?e="webMercator":((s.wkid&&N[s.wkid])!=null||(s.wkt2||s.wkt)&&Q(s.wkt2||s.wkt))&&(e="projected"),this.geodesic){let a;switch(e){case"webMercator":a=A(n);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":a=n}r=this._createGeodesicCircle(a,i,t),e==="webMercator"&&(r=B(r))}else{let a;e==="webMercator"||e==="projected"?a=i/D(n.spatialReference):e==="geographic"&&(a=J(i,"meters",K(n.spatialReference).radius)),r=this._createPlanarCircle(n,a,t)}this.spatialReference=r.spatialReference,this.addRing(r.rings[0])}clone(){const{center:n,numberOfPoints:t,radius:i,radiusUnit:s,geodesic:r}=this;return new I({center:n?.clone(),numberOfPoints:t,radius:i,radiusUnit:s,geodesic:r})}_createGeodesicCircle(n,t,i){const s=[],r=[n.x,n.y];for(let e=0;e<360;e+=360/i){const a=this.hasZ?[0,0,n.z??0]:[0,0];V(a,r,e,t,X.WGS84),s.push(a)}return s.push(s[0]),new k({rings:[s]})}_createPlanarCircle(n,t,i){const s=[],r=2*Math.PI/i;for(let e=0;e<i;++e){const a=r*e,c=[n.x+Math.cos(-a)*t,n.y+Math.sin(-a)*t];this.hasZ&&c.push(n.z??0),s.push(c)}return s.push(s[0]),new k({spatialReference:n.spatialReference,rings:[s]})}};w([P({type:Z})],m.prototype,"center",void 0),w([P()],m.prototype,"geodesic",void 0),w([P()],m.prototype,"numberOfPoints",void 0),w([P()],m.prototype,"radius",void 0),w([P()],m.prototype,"radiusUnit",void 0),m=I=w([Y("esri.geometry.Circle")],m);const pe=m;function g(n,t){const i=new Z({x:n[0],y:n[1],spatialReference:t});return n.length>2&&(i.z=n[2]),i}function de(n,t){return new ie({points:n,spatialReference:t})}function Me(n,t,i){const s=new re({paths:n,spatialReference:t});return i&&G(s),s}function v(n,t,i,s=!0){const r=ae(n);r.forEach(a=>{const c=a[0],l=a[a.length-1];se(c,l)&&a.length!==1||a.push(a[0])});let e=new k({rings:r,spatialReference:t});return e.rings.forEach(a=>{ne(a)||a.reverse()}),i&&G(e),s&&!ce(e)&&_(t)&&(e=ue(e)||e),e}function me(n,t,i){const s=t.mapToLocalMultiple(n),r=[],e={x:s[0].x,y:s[0].y},a={x:s[1].x,y:s[1].y},c=Math.round(a.x-e.x),l=Math.round(a.y-e.y),h=Math.max(Math.abs(c),Math.abs(l));if(i){const u={x:e.x+h,y:e.y+h},y={x:e.x-h,y:e.y-h};r.push(o(u.x,y.y),o(y.x,y.y),o(y.x,u.y),o(u.x,u.y))}else{const u={x:c>0?e.x+h:e.x-h,y:l>0?e.y+h:e.y-h};r.push(o(e.x,e.y),o(u.x,e.y),o(u.x,u.y),o(e.x,u.y))}return F(v([r.map(u=>t.localToMap(u)).filter(C)],t.spatialReference,t.doUnnormalization,!0),r,t)}function ge(n,t,i){let s=t.mapToLocalMultiple(n);if(s.length===1){const l=s[0];s=[o(l.x-48,l.y+48),o(l.x+48,l.y-48),o(l.x+48,l.y-48),o(l.x-48,l.y+48)]}const r=[],e={x:s[0].x,y:s[0].y},a={x:s[1].x,y:s[1].y};if(i){const c=Math.round(a.x-e.x),l=Math.round(a.y-e.y);r.push(o(e.x-c,e.y-l),o(a.x,e.y-l),o(a.x,a.y),o(e.x-c,a.y))}else r.push(o(e.x,e.y),o(a.x,e.y),o(a.x,a.y),o(e.x,a.y));return F(v([r.map(c=>t.localToMap(c)).filter(C)],t.spatialReference,t.doUnnormalization,!0),r,t)}function F(n,t,i){const s=z(t[3],t[2],i),r=z(t[1],t[2],i),e=z(t[0],t[1],i),a=z(t[0],t[3],i);return{geometry:n,midpoints:s!=null&&r!=null&&e!=null&&a!=null?{top:s,right:r,bottom:e,left:a}:null}}function z(n,t,i){$[0]=n.x,$[1]=n.y,$[2]=0,j[0]=t.x,j[1]=t.y,j[2]=0,oe($,$,j,.5),U.x=$[0],U.y=j[1],U.z=j[2];const s=i.localToMap(U);return s!=null?g(s,i.spatialReference):null}const U=o(0,0,0),$=q(),j=q();function Re(n,t,i,s){const r=t.mapToLocalMultiple(n);let e=null,a=null;if(i)e=r[0],a=r[1];else{const p=r[0],f=r[1],R=Math.round(f.x-p.x),b=Math.round(f.y-p.y),x=Math.max(Math.abs(R),Math.abs(b));e=o(R>0?p.x+x/2:p.x-x/2,b>0?p.y+x/2:p.y-x/2),a=o(Math.abs(R)>Math.abs(b)?e.x-x/2:e.x,Math.abs(R)>Math.abs(b)?e.y:e.y-x/2)}const c=t.localToMap(e),l=t.localToMap(a);if(c==null||l==null)return null;t.doUnnormalization&&ee([[c,l]],t.spatialReference);const h=g(c,t.spatialReference),u=g(l,t.spatialReference),y=te(t.spatialReference);let d=0;if(_(t.spatialReference))d=y*le(h,u);else{const p=e.x-a.x,f=e.y-a.y;d=y*Math.sqrt(p*p+f*f)*(s||1)}const T=new pe({center:h,radius:d,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:v(T.rings,T.spatialReference,!1),center:h,edge:u}}function be(n,t,i){const s=t.mapToLocalMultiple(n),r=s[0],e=s[1],a=Math.round(e.x-r.x),c=Math.round(e.y-r.y),l=o(i?r.x:r.x+a/2,i?r.y:r.y+c/2),h=i?a:a/2,u=i?c:c/2,y=60,d=[],T=2*Math.PI/y;function p(M){const S=Math.cos(M),W=Math.sin(M);return o(h*S+l.x,u*W+l.y)}for(let M=0;M<y;M++)d.push(p(M*T));d.push(d[0]);const{spatialReference:f,doUnnormalization:R}=t,b=v([d.map(M=>t.localToMap(M)).filter(C)],f,R,!1),x=t.localToMap(p(Math.PI/2)),L=t.localToMap(p(0)),E=t.localToMap(p(-Math.PI/2)),O=t.localToMap(p(Math.PI));return{geometry:b,midpoints:x!=null&&L!=null&&E!=null&&O!=null?{top:g(x,f),right:g(L,f),bottom:g(E,f),left:g(O,f)}:null}}export{de as R,v as T,ge as U,me as b,Me as j,Re as k,be as v};
