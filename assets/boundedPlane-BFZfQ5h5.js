import{b0 as E,dg as y,cb as u,bV as S,dh as F,aZ as I,di as m,e as rn,dj as Y,dk as on,bY as cn,bW as R,dl as un,dm as h,dn as w,dp as gn,dq as f,au as M,dr as l,ds as bn,dt as k,du as r,dv as N,dw as $,dx as dn,dy as D,dz as fn,dA as ln,dB as pn,dC as hn,dD as U,aP as V,dE as In,dF as mn,dG as Pn,dH as Mn,dI as Nn,dJ as $n,dK as wn,dL as G,dM as vn,dN as _,b2 as K}from"./index-v3vBpdnQ.js";const O=()=>rn.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class yn{constructor(){this.plane=y(),this.origin=M(),this.basis1=M(),this.basis2=M()}}const An=yn;function P(n=an){return{plane:y(n.plane),origin:S(n.origin),basis1:S(n.basis1),basis2:S(n.basis2)}}function Tn(n,i,s){const t=Gn.get();return t.origin=n,t.basis1=i,t.basis2=s,t.plane=on(0,0,0,0),T(t),t}function A(n,i=P()){return W(n.origin,n.basis1,n.basis2,i)}function xn(n,i){u(i.origin,n.origin),u(i.basis1,n.basis1),u(i.basis2,n.basis2),mn(i.plane,n.plane)}function W(n,i,s,t=P()){return u(t.origin,n),u(t.basis1,i),u(t.basis2,s),T(t),Hn(t,"fromValues()"),t}function T(n){F(n.basis2,n.basis1,n.origin,n.plane)}function Z(n,i,s){n!==s&&A(n,s);const t=f(r.get(),d(n),i);return l(s.origin,s.origin,t),s.plane[3]-=i,s}function En(n,i,s){return J(i,s),Z(s,z(n,n.origin),s),s}function Sn(n,i){const s=n.basis1[0],t=n.basis2[1],[e,a]=n.origin;return pn(e-s,a-t,e+s,a+t,i)}function J(n,i=P()){const s=(n[2]-n[0])/2,t=(n[3]-n[1])/2;return $(i.origin,n[0]+s,n[1]+t,0),$(i.basis1,s,0,0),$(i.basis2,0,t,0),hn(0,0,1,0,i.plane),i}function q(n,i,s){return!!ln(n.plane,i,s)&&tn(n,s)}function Vn(n,i,s){if(q(n,i,s))return s;const t=X(n,i,r.get());return l(s,i.origin,f(r.get(),i.direction,fn(i.origin,t)/m(i.direction))),s}function X(n,i,s){const t=v.get();en(n,i,t,v.get());let e=Number.POSITIVE_INFINITY;for(const a of H){const o=B(n,a,x.get()),g=r.get();if(Pn(t,o,g)){const c=Mn(r.get(),i.origin,g),b=Math.abs(Nn(I(i.direction,c)));b<e&&(e=b,u(s,g))}}return e===Number.POSITIVE_INFINITY?Q(n,i,s):s}function _n(n,i){return(i-n)/i}function Q(n,i,s){if(q(n,i,s))return s;const t=v.get(),e=v.get();en(n,i,t,e);let a=Number.POSITIVE_INFINITY;for(const o of H){const g=B(n,o,x.get()),c=r.get();if($n(t,g,c)){const b=wn(i,c);if(!U(e,c))continue;b<a&&(a=b,u(s,c))}}return C(n,i.origin)<a&&nn(n,i.origin,s),s}function nn(n,i,s){const t=dn(n.plane,i,r.get()),e=D(L(n,n.basis1),t,-1,1,r.get()),a=D(L(n,n.basis2),t,-1,1,r.get());return k(s,l(r.get(),e,a),n.origin),s}function sn(n,i,s){const{origin:t,basis1:e,basis2:a}=n,o=k(r.get(),i,t),g=N(e,o),c=N(a,o),b=N(d(n),o);return $(s,g,c,b)}function C(n,i){const s=sn(n,i,r.get()),{basis1:t,basis2:e}=n,a=m(t),o=m(e),g=Math.max(Math.abs(s[0])-a,0),c=Math.max(Math.abs(s[1])-o,0),b=s[2];return g*g+c*c+b*b}function On(n,i){return Math.sqrt(C(n,i))}function jn(n,i){let s=Number.NEGATIVE_INFINITY;for(const t of H){const e=B(n,t,x.get()),a=In(e,i);a>s&&(s=a)}return Math.sqrt(s)}function Fn(n,i){return U(n.plane,i)&&tn(n,i)}function Yn(n,i,s,t){return Bn(n,s,t)}function z(n,i){const s=-n.plane[3];return N(d(n),i)-s}function kn(n,i,s,t){const e=z(n,i),a=f(Dn,d(n),s-e);return l(t,i,a),t}function qn(n,i){return V(n.basis1,i.basis1)&&V(n.basis2,i.basis2)&&V(n.origin,i.origin)}function Cn(n,i,s){return n!==s&&A(n,s),cn(p,i),un(p,p),h(s.basis1,n.basis1,p),h(s.basis2,n.basis2,p),h(w(s.plane),w(n.plane),p),h(s.origin,n.origin,i),gn(s.plane,s.plane,s.origin),s}function zn(n,i,s,t){return n!==t&&A(n,t),bn(j,i,s),h(t.basis1,n.basis1,j),h(t.basis2,n.basis2,j),T(t),t}function d(n){return w(n.plane)}function Bn(n,i,s){switch(i){case _.X:u(s,n.basis1),K(s,s);break;case _.Y:u(s,n.basis2),K(s,s);break;case _.Z:u(s,d(n))}return s}function tn(n,i){const s=k(r.get(),i,n.origin),t=G(n.basis1),e=G(n.basis2),a=I(n.basis1,s),o=I(n.basis2,s);return-a-t<0&&a-t<0&&-o-e<0&&o-e<0}function L(n,i){const s=x.get();return u(s.origin,n.origin),u(s.vector,i),s}function B(n,i,s){const{basis1:t,basis2:e,origin:a}=n,o=f(r.get(),t,i.origin[0]),g=f(r.get(),e,i.origin[1]);l(s.origin,o,g),l(s.origin,s.origin,a);const c=f(r.get(),t,i.direction[0]),b=f(r.get(),e,i.direction[1]);return f(s.vector,l(c,c,b),2),s}function Hn(n,i){Math.abs(I(n.basis1,n.basis2)/(m(n.basis1)*m(n.basis2)))>1e-6&&O().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(I(n.basis1,d(n)))>1e-6&&O().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-I(d(n),n.origin)-n.plane[3])>1e-6&&O().warn(i,"Plane offset is not consistent with plane origin")}function en(n,i,s,t){const e=d(n);F(e,i.direction,i.origin,s),F(w(s),e,i.origin,t)}const an={plane:y(),origin:E(0,0,0),basis1:E(1,0,0),basis2:E(0,1,0)},v=new Y(y),x=new Y(vn),Dn=M(),Gn=new Y(()=>P()),H=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],p=R(),j=R(),Ln=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:An,altitudeAt:z,axisAt:Yn,cameraFrustumCoverage:_n,closestPoint:Q,closestPointOnSilhouette:X,copy:A,copyWithoutVerify:xn,create:P,distance:On,distance2:C,distanceToSilhouette:jn,elevate:Z,equals:qn,extrusionContainsPoint:Fn,fromAABoundingRect:J,fromValues:W,getExtent:Sn,intersectRay:q,intersectRayClosestSilhouette:Vn,normal:d,projectPoint:nn,projectPointLocal:sn,rotate:zn,setAltitudeAt:kn,setExtent:En,transform:Cn,up:an,updateUnboundedPlane:T,wrap:Tn},Symbol.toStringTag,{value:"Module"}));export{W as J,T as K,P as W,A as Z,On as g,Ln as k,J as t};
