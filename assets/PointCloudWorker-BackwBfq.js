import{ke as k,P as O,ap as v,hh as x,kf as C,bd as F}from"./index-v3vBpdnQ.js";import{O as R}from"./quat-CzjAuFtU.js";import{t as A,n as w}from"./vec3f32-WCVSSNPR.js";import{u as U,d as B,a as J}from"./PointCloudUniqueValueRenderer-D5hA6BHY.js";import{U as N,w as V,c as T,D as q}from"./I3SBinaryReader-DEGzjKmz.js";import{I as $}from"./orientedBoundingBox-z2qmkSHi.js";import"./VertexAttribute-BfkzOMLV.js";import"./computeTranslationToOriginAndRotation-BD5S3siZ.js";function z(i,t,a,n){const{rendererJSON:c,isRGBRenderer:p}=i;let o=null,u=null;if(t&&p)o=t;else if(t&&c?.type==="pointCloudUniqueValueRenderer"){u=U.fromJSON(c);const e=u.colorUniqueValueInfos;o=new Uint8Array(3*n);const f=g(u.fieldTransformType);for(let r=0;r<n;r++){const l=(f?f(t[r]):t[r])+"";for(let s=0;s<e.length;s++)if(e[s].values.includes(l)){o[3*r]=e[s].color.r,o[3*r+1]=e[s].color.g,o[3*r+2]=e[s].color.b;break}}}else if(t&&c?.type==="pointCloudStretchRenderer"){u=B.fromJSON(c);const e=u.stops;o=new Uint8Array(3*n);const f=g(u.fieldTransformType);for(let r=0;r<n;r++){const l=f?f(t[r]):t[r],s=e.length-1;if(l<e[0].value)o[3*r]=e[0].color.r,o[3*r+1]=e[0].color.g,o[3*r+2]=e[0].color.b;else if(l>=e[s].value)o[3*r]=e[s].color.r,o[3*r+1]=e[s].color.g,o[3*r+2]=e[s].color.b;else for(let b=1;b<e.length;b++)if(l<e[b].value){const m=(l-e[b-1].value)/(e[b].value-e[b-1].value);o[3*r]=e[b].color.r*m+e[b-1].color.r*(1-m),o[3*r+1]=e[b].color.g*m+e[b-1].color.g*(1-m),o[3*r+2]=e[b].color.b*m+e[b-1].color.b*(1-m);break}}}else if(t&&c?.type==="pointCloudClassBreaksRenderer"){u=J.fromJSON(c);const e=u.colorClassBreakInfos;o=new Uint8Array(3*n);const f=g(u.fieldTransformType);for(let r=0;r<n;r++){const l=f?f(t[r]):t[r];for(let s=0;s<e.length;s++)if(l>=e[s].minValue&&l<=e[s].maxValue){o[3*r]=e[s].color.r,o[3*r+1]=e[s].color.g,o[3*r+2]=e[s].color.b;break}}}else o=new Uint8Array(3*n).fill(255);if(a&&u?.colorModulation){const e=u.colorModulation.minValue,f=u.colorModulation.maxValue,r=.3;for(let l=0;l<n;l++){const s=a[l],b=s>=f?1:s<=e?r:r+(1-r)*(s-e)/(f-e);o[3*l]=b*o[3*l],o[3*l+1]=b*o[3*l+1],o[3*l+2]=b*o[3*l+2]}}return o}function E(i,t){if(i.encoding==null||i.encoding===""){const a=N(t,i);if(a.vertexAttributes.position==null)return;const n=V(t,a.vertexAttributes.position),c=a.header.fields,p=[c.offsetX,c.offsetY,c.offsetZ],o=[c.scaleX,c.scaleY,c.scaleZ],u=n.length/3,e=new Float64Array(3*u);for(let f=0;f<u;f++)e[3*f]=n[3*f]*o[0]+p[0],e[3*f+1]=n[3*f+1]*o[1]+p[1],e[3*f+2]=n[3*f+2]*o[2]+p[2];return e}if(i.encoding==="lepcc-xyz")return T(t).result}function h(i,t,a){return i?.attributeInfo.useElevation?t?L(t,a):null:i?.attributeInfo.storageInfo?q(i.attributeInfo.storageInfo,i.buffer,a,!0):null}function L(i,t){const a=new Float64Array(t);for(let n=0;n<t;n++)a[n]=i[3*n+2];return a}function P(i,t,a,n,c){const p=i.length/3;let o=0;for(let u=0;u<p;u++){let e=!0;for(let f=0;f<n.length&&e;f++){const{filterJSON:r}=n[f],l=c[f].values[u];switch(r.type){case"pointCloudValueFilter":{const s=r.mode==="exclude";r.values.includes(l)===s&&(e=!1);break}case"pointCloudBitfieldFilter":{const s=M(r.requiredSetBits),b=M(r.requiredClearBits);(l&s)===s&&(l&b)===0||(e=!1);break}case"pointCloudReturnFilter":{const s=15&l,b=l>>>4&15,m=b>1,S=s===1,I=s===b;let y=!1;for(const d of r.includedReturns)if(d==="last"&&I||d==="firstOfMany"&&S&&m||d==="lastOfMany"&&I&&m||d==="single"&&!m){y=!0;break}y||(e=!1);break}}}e&&(a[o]=u,i[3*o]=i[3*u],i[3*o+1]=i[3*u+1],i[3*o+2]=i[3*u+2],t[3*o]=t[3*u],t[3*o+1]=t[3*u+1],t[3*o+2]=t[3*u+2],o++)}return o}function g(i){switch(i){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function M(i){let t=0;for(const a of i||[])t|=1<<a;return t}class X{transform(t){const a=this._transform(t),n=[a.points.buffer,a.rgb.buffer];a.pointIdFilterMap!=null&&n.push(a.pointIdFilterMap.buffer);for(const c of a.attributes)"buffer"in c.values&&k(c.values.buffer)&&c.values.buffer!==a.rgb.buffer&&n.push(c.values.buffer);return Promise.resolve({result:a,transferList:n})}_transform(t){const a=E(t.schema,t.geometryBuffer);let n=a.length/3,c=null;const p=new Array,o=h(t.primaryAttributeData,a,n);t.primaryAttributeData!=null&&o&&p.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:o});const u=h(t.modulationAttributeData,a,n);t.modulationAttributeData!=null&&u&&p.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:u});let e=z(t.rendererInfo,o,u,n);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const r=t.filterAttributesData.filter(O).map(l=>{const s=h(l,a,n),b={attributeInfo:l.attributeInfo,values:s};return p.push(b),b});c=new Uint32Array(n),n=P(a,e,c,t.filterInfo,r)}for(const r of t.userAttributesData){const l=h(r,a,n);p.push({attributeInfo:r.attributeInfo,values:l})}3*n<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*n))),Z(a,n,t.elevationOffset);const f=Y(a,n,$.fromData(t.obbData),v.fromJSON(t.inSR),v.fromJSON(t.outSR));return{obbData:t.obbData,points:f,rgb:e,attributes:p,pointIdFilterMap:c}}}function Y(i,t,a,n,c){if(!x(i,n,0,i,c,0,t))throw new Error("Can't reproject");const p=A(a.center),o=w(),u=w(),e=A(a.halfSize);R(D,a.quaternion);const f=new Float32Array(3*t);for(let r=0;r<t;r++){let l=3*r;o[0]=i[l]-p[0],o[1]=i[l+1]-p[1],o[2]=i[l+2]-p[2],C(u,o,D),e[0]=Math.max(e[0],Math.abs(u[0])),e[1]=Math.max(e[1],Math.abs(u[1])),e[2]=Math.max(e[2],Math.abs(u[2])),f[l++]=o[0],f[l++]=o[1],f[l]=o[2]}return a.halfSize=e,f}function Z(i,t,a){if(a!==0)for(let n=0;n<t;n++)i[3*n+2]+=a}const D=F();function et(){return new X}export{et as default};
